<!-- Based on: https://gist.github.com/mbostock/999346
     else, by Ethan Petuchowski, started 5/18/14
     meant to be a Java tree testcase generator,
     once I figure out enough of the base-code to
     be able to make it do what I want. -->

<!DOCTYPE html>
<meta charset="utf-8">
<style>

/* node outline */
.node {
  stroke: #3E7;
  stroke-width: 2px;
}

.link {
  fill: none;
  stroke: #000;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

// dimensions of the diagram on the page (this is not "responsive")
var width = 960,
    height = 500,
    update_interval = 350,
    max_size = 3;

// construct tree with all default settings except for the size
// github.com/mbostock/d3/wiki/Tree-Layout
// set layout size to be slightly smaller than width, height setting above
var tree = d3.layout.tree()
    .size([width - 20, height - 20]);

var root = {},
    nodes = tree(root); // Runs the tree layout, returning the array of
                        // nodes associated with the specified root node.

root.parent = root;
root.px = root.x; // I think we're saving the current values so that these
root.py = root.y; // values will still be available after the root moves

// returns a function that generates the path data for
// a cubic Bézier connecting the source and target points
var diagonal = d3.svg.diagonal();


// I guess we're appending a giant svg elem to the body
// that will contain the entire tree
//
// the tree is inset (20,20), so we translate(10,10)
// i.e. move the whole tree that direction
// developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(10,10)");

// Once we have a selection, we can apply various operators to the selected elements.
// For example, we might change the fill color using style,
// and the radius and the y-position using attr
// mbostock.github.io/d3/tutorial/circle.html
var node = svg.selectAll(".node"),
    link = svg.selectAll(".link");

// run `update()` every 750 ms
var timer = setInterval(update, update_interval);

newChildDialog(root);

// TODO perhaps this should be taken off the timer, and instead the trees should
// be generated by hand based on clicking the node to create a child of
function update() {
  if (nodes.length >= max_size) {
    // clears a timer set with the setInterval() method
    // in this case, prevents the tree from growing any bigger
    return clearInterval(timer);
  }

  // create a new node with a unique id
  // TODO maybe this is where we should give it a value,
  //      and the way that value is assigned will ensure
  //      that the tree as a whole is sorted
  var n = {id: nodes.length},  // should initially be 1 (root)

      // we're choosing a node to be the parent
      // TODO here we could restrict it to a Binary Tree
      // the `| 0` casts (quickly[!]) to Integer (stackoverflow.com/questions/596467)
      p = nodes[Math.random() * nodes.length | 0];

  // add new node to its parent's list of children
  if (p.children) p.children.push(n);
  else p.children = [n];

  // add new node to the tree's list of nodes
  nodes.push(n);

  // Recompute the layout and data join.
  // not sure how this works
  node = node.data(tree.nodes(root), function(d) { return d.id; });
  link = link.data(tree.links(nodes), function(d) { return d.source.id + "-" + d.target.id; });

  // Add entering node in the parent’s old position.
  node.enter().append("circle")
      .attr("class", "node")
      .attr("r", 4)
      .attr("cx", function(d) { return d.parent.px; })
      .attr("cy", function(d) { return d.parent.py; })
      .on("click", newChildDialog)

  // Add entering link in the parent’s old position.
  // this way it'll animate nicely to its true location
  // at the same time everything else is relocating
  link.enter().insert("path", ".node")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: d.source.px, y: d.source.py};
        return diagonal({source: o, target: o});
      });

  // Transition (relocate) nodes and links to their new positions.
  var t = svg.transition()
      .duration(update_interval);

  t.selectAll(".link")
      .attr("d", diagonal);

  // store current locations so that they will be available
  // after the next time all the locations get updated
  t.selectAll(".node")
      .attr("cx", function(d) { return d.px = d.x; })
      .attr("cy", function(d) { return d.py = d.y; });
}


/***************** HERE'S WHERE MY STUFF STARTS *****************/
// TODO collect all the connections
// we have root.children means

// seems this is the preferred technical spelling of the word "dialogue"
function newChildDialog(clickedParent) {
  var val = prompt("Please enter the new node's value, it must make sense too!");
  var newNode = {id: nodes.length, value: val};
  if (clickedParent.children) clickedParent.children.push(newNode);
  else clickedParent.children = [newNode];
  nodes.push(newNode);


  // Recompute the layout and data join.
  // not sure how this works
  node = node.data(tree.nodes(root), function(d) { return d.id; });
  link = link.data(tree.links(nodes), function(d) { return d.source.id + "-" + d.target.id; });

  // Add entering node in the parent’s old position.
  node.enter().append("circle")
      .attr("class", "node")
      .attr("r", 4)
      .attr("cx", function(d) { return d.parent.px; })
      .attr("cy", function(d) { return d.parent.py; })
      .on("click", newChildDialog);

  // Add entering link in the parent’s old position.
  // this way it'll animate nicely to its true location
  // at the same time everything else is relocating
  link.enter().insert("path", ".node")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: d.source.px, y: d.source.py};
        return diagonal({source: o, target: o});
      });

  // Transition (relocate) nodes and links to their new positions.
  var t = svg.transition()
      .duration(update_interval);

  t.selectAll(".link")
      .attr("d", diagonal);

  // store current locations so that they will be available
  // after the next time all the locations get updated
  t.selectAll(".node")
      .attr("cx", function(d) { return d.px = d.x; })
      .attr("cy", function(d) { return d.py = d.y; });
}


</script>
<pre>
boolean testCase_N() {
  BST bst = BST<BSTN<Int>>(r.nextInt());
  bst.getRoot().setLeft(new BSTN<Int>(r.nextInt()));
  return bst.test_N == /* TODO FILL IN VALUE */);
}
